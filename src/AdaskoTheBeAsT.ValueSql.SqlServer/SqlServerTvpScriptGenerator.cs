using System;
using System.Collections.Generic;
using System.Security.Cryptography;
using System.Text;
using AdaskoTheBeAsT.ValueSql.SourceGenerator;

namespace AdaskoTheBeAsT.ValueSql.SqlServer;

/// <summary>
/// Generates SQL scripts for TVP type creation and validation.
/// </summary>
public static class SqlServerTvpScriptGenerator
{
    /// <summary>
    /// Generates a complete SQL migration script for a TVP.
    /// </summary>
    /// <param name="schema">The schema name.</param>
    /// <param name="typeName">The TVP type name.</param>
    /// <param name="columns">The column definitions.</param>
    /// <param name="includeDropIfDifferent">Whether to drop and recreate if schema changed.</param>
    /// <returns>The SQL migration script.</returns>
    public static string GenerateMigrationScript(
        string schema,
        string typeName,
        IList<PropertyColumnInfo> columns,
        bool includeDropIfDifferent = true)
    {
        var sb = new StringBuilder(2048);
        var fullTypeName = string.IsNullOrEmpty(schema) ? typeName : $"{schema}.{typeName}";
        var schemaName = string.IsNullOrEmpty(schema) ? "dbo" : schema;

        GenerateHeader(sb, fullTypeName);
        GenerateHashCheck(sb, schemaName, typeName, columns, includeDropIfDifferent);
        GenerateCreateType(sb, schemaName, typeName, columns);
        GenerateFooter(sb);

        return sb.ToString();
    }

    /// <summary>
    /// Generates SQL to query current TVP definition from database.
    /// </summary>
    /// <param name="schema">The schema name.</param>
    /// <param name="typeName">The TVP type name.</param>
    /// <returns>SQL query to get TVP column definitions.</returns>
    public static string GenerateComparisonQuery(string schema, string typeName)
    {
        var schemaName = string.IsNullOrEmpty(schema) ? "dbo" : schema;

        return $"""
            SELECT 
                c.name AS ColumnName,
                t.name AS DataType,
                c.max_length AS MaxLength,
                c.[precision] AS [Precision],
                c.scale AS Scale,
                c.is_nullable AS IsNullable,
                c.column_id AS Ordinal
            FROM sys.table_types tt
            INNER JOIN sys.schemas s ON tt.schema_id = s.schema_id
            INNER JOIN sys.columns c ON c.object_id = tt.type_table_object_id
            INNER JOIN sys.types t ON c.user_type_id = t.user_type_id
            WHERE s.name = '{schemaName}' AND tt.name = '{typeName}'
            ORDER BY c.column_id;
            """;
    }

    /// <summary>
    /// Generates a C# validation class for comparing TVP definitions.
    /// </summary>
    /// <param name="namespaceName">The namespace for the generated class.</param>
    /// <param name="className">The base class name.</param>
    /// <param name="schema">The schema name.</param>
    /// <param name="typeName">The TVP type name.</param>
    /// <param name="columns">The column definitions.</param>
    /// <returns>Generated C# validation class code.</returns>
    public static string GenerateValidationClass(
        string namespaceName,
        string className,
        string schema,
        string typeName,
        IList<PropertyColumnInfo> columns)
    {
        var sb = new StringBuilder(2048);
        var schemaName = string.IsNullOrEmpty(schema) ? "dbo" : schema;

        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine();
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Threading;");
        sb.AppendLine("using System.Threading.Tasks;");
        sb.AppendLine("using Microsoft.Data.SqlClient;");
        sb.AppendLine();
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Validation utilities for {className} TVP.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine($"public static class {className}TvpValidator");
        sb.AppendLine("{");

        GenerateExpectedColumnsArray(sb, columns);
        GenerateExistsMethod(sb, schemaName, typeName);
        GenerateValidateAsyncMethod(sb, schemaName, typeName);
        GenerateValidateSyncMethod(sb, schemaName, typeName);
        GenerateGetHashMethod(sb, columns);

        sb.AppendLine("}");

        return sb.ToString();
    }

    private static void GenerateHeader(StringBuilder sb, string fullTypeName)
    {
        sb.AppendLine("/*");
        sb.AppendLine($"  TVP Migration Script: {fullTypeName}");
        sb.AppendLine($"  Generated: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss} UTC");
        sb.AppendLine("  ");
        sb.AppendLine("  This script:");
        sb.AppendLine("  1. Checks if the TVP type exists");
        sb.AppendLine("  2. Compares the hash of expected vs actual columns");
        sb.AppendLine("  3. Drops and recreates if different (optional)");
        sb.AppendLine("  4. Creates the type if it doesn't exist");
        sb.AppendLine("*/");
        sb.AppendLine();
        sb.AppendLine("SET NOCOUNT ON;");
        sb.AppendLine("SET XACT_ABORT ON;");
        sb.AppendLine();
    }

    private static void GenerateHashCheck(
        StringBuilder sb,
        string schemaName,
        string typeName,
        IList<PropertyColumnInfo> columns,
        bool includeDropIfDifferent)
    {
        var expectedHash = ComputeDefinitionHash(columns);

        GenerateHashVariables(sb, expectedHash);
        GenerateHashComputation(sb, schemaName, typeName);

        if (includeDropIfDifferent)
        {
            GenerateDropIfDifferent(sb, schemaName, typeName);
        }
    }

    private static void GenerateHashVariables(StringBuilder sb, string expectedHash)
    {
        sb.AppendLine("DECLARE @TypeExists BIT = 0;");
        sb.AppendLine("DECLARE @CurrentHash NVARCHAR(64) = NULL;");
        sb.AppendLine($"DECLARE @ExpectedHash NVARCHAR(64) = '{expectedHash}';");
        sb.AppendLine();
    }

    private static void GenerateHashComputation(StringBuilder sb, string schemaName, string typeName)
    {
        sb.AppendLine("-- Check if type exists and get current definition hash");
        sb.AppendLine($"IF TYPE_ID('[{schemaName}].[{typeName}]') IS NOT NULL");
        sb.AppendLine("BEGIN");
        sb.AppendLine("    SET @TypeExists = 1;");
        sb.AppendLine("    ");
        sb.AppendLine("    -- Compute hash of current column definitions");
        sb.AppendLine("    SELECT @CurrentHash = CONVERT(NVARCHAR(64), HASHBYTES('SHA2_256',");
        sb.AppendLine("        (SELECT STRING_AGG(");
        sb.AppendLine("            c.name + '|' + t.name + '|' + ");
        sb.AppendLine("            CAST(c.max_length AS NVARCHAR) + '|' + ");
        sb.AppendLine("            CAST(c.[precision] AS NVARCHAR) + '|' + ");
        sb.AppendLine("            CAST(c.scale AS NVARCHAR) + '|' + ");
        sb.AppendLine("            CAST(c.is_nullable AS NVARCHAR),");
        sb.AppendLine("            ','");
        sb.AppendLine("        ) WITHIN GROUP (ORDER BY c.column_id)");
        sb.AppendLine("        FROM sys.table_types tt");
        sb.AppendLine("        INNER JOIN sys.schemas s ON tt.schema_id = s.schema_id");
        sb.AppendLine("        INNER JOIN sys.columns c ON c.object_id = tt.type_table_object_id");
        sb.AppendLine("        INNER JOIN sys.types t ON c.user_type_id = t.user_type_id");
        sb.AppendLine($"        WHERE s.name = '{schemaName}' AND tt.name = '{typeName}'");
        sb.AppendLine("    )), 2);");
        sb.AppendLine("END");
        sb.AppendLine();
    }

    private static void GenerateDropIfDifferent(StringBuilder sb, string schemaName, string typeName)
    {
        sb.AppendLine("-- Drop type if hash is different (schema changed)");
        sb.AppendLine("IF @TypeExists = 1 AND @CurrentHash <> @ExpectedHash");
        sb.AppendLine("BEGIN");
        sb.AppendLine($"    PRINT 'TVP [{schemaName}].[{typeName}] schema changed. Dropping...';");
        sb.AppendLine("    ");
        sb.AppendLine("    -- Check if type is in use");
        sb.AppendLine("    IF EXISTS (");
        sb.AppendLine("        SELECT 1 FROM sys.parameters p");
        sb.AppendLine("        INNER JOIN sys.table_types tt ON p.user_type_id = tt.user_type_id");
        sb.AppendLine("        INNER JOIN sys.schemas s ON tt.schema_id = s.schema_id");
        sb.AppendLine($"        WHERE s.name = '{schemaName}' AND tt.name = '{typeName}'");
        sb.AppendLine("    )");
        sb.AppendLine("    BEGIN");
        sb.AppendLine($"        RAISERROR('Cannot drop TVP [{schemaName}].[{typeName}] - it is referenced by stored procedures. Drop them first.', 16, 1);");
        sb.AppendLine("        RETURN;");
        sb.AppendLine("    END");
        sb.AppendLine("    ");
        sb.AppendLine($"    DROP TYPE [{schemaName}].[{typeName}];");
        sb.AppendLine("    SET @TypeExists = 0;");
        sb.AppendLine("END");
        sb.AppendLine();
    }

    private static void GenerateCreateType(
        StringBuilder sb,
        string schemaName,
        string typeName,
        IList<PropertyColumnInfo> columns)
    {
        sb.AppendLine("-- Create type if it doesn't exist");
        sb.AppendLine("IF @TypeExists = 0");
        sb.AppendLine("BEGIN");
        sb.AppendLine($"    PRINT 'Creating TVP [{schemaName}].[{typeName}]...';");
        sb.AppendLine("    ");
        sb.AppendLine($"    CREATE TYPE [{schemaName}].[{typeName}] AS TABLE");
        sb.AppendLine("    (");

        for (var i = 0; i < columns.Count; i++)
        {
            var col = columns[i];
            var sqlType = GetSqlColumnDefinition(col);
            var nullable = col.IsNullable ? "NULL" : "NOT NULL";
            var comma = i < columns.Count - 1 ? "," : string.Empty;
            var columnName = col.ColumnName ?? col.PropertyName;

            sb.AppendLine($"        [{columnName}] {sqlType} {nullable}{comma}");
        }

        sb.AppendLine("    );");
        sb.AppendLine("    ");
        sb.AppendLine($"    PRINT 'TVP [{schemaName}].[{typeName}] created successfully.';");
        sb.AppendLine("END");
        sb.AppendLine("ELSE IF @CurrentHash = @ExpectedHash");
        sb.AppendLine("BEGIN");
        sb.AppendLine($"    PRINT 'TVP [{schemaName}].[{typeName}] already exists and is up to date.';");
        sb.AppendLine("END");
    }

    private static void GenerateFooter(StringBuilder sb)
    {
        sb.AppendLine();
        sb.AppendLine("GO");
    }

    private static void GenerateExpectedColumnsArray(StringBuilder sb, IList<PropertyColumnInfo> columns)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Expected column definitions for validation.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static readonly (string Name, string SqlType, bool IsNullable)[] ExpectedColumns =");
        sb.AppendLine("    [");

        for (var i = 0; i < columns.Count; i++)
        {
            var col = columns[i];
            var columnName = col.ColumnName ?? col.PropertyName;
            var sqlType = GetSqlColumnDefinition(col);
            var nullable = col.IsNullable ? "true" : "false";
            var comma = i < columns.Count - 1 ? "," : string.Empty;

            sb.AppendLine($"        (\"{columnName}\", \"{sqlType}\", {nullable}){comma}");
        }

        sb.AppendLine("    ];");
        sb.AppendLine();
    }

    private static void GenerateExistsMethod(StringBuilder sb, string schemaName, string typeName)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Checks if the TVP type exists in the database.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static async Task<bool> ExistsAsync(SqlConnection connection, CancellationToken ct = default)");
        sb.AppendLine("    {");
        sb.AppendLine("        await using var cmd = connection.CreateCommand();");
        sb.AppendLine($"        cmd.CommandText = \"SELECT CASE WHEN TYPE_ID('[{schemaName}].[{typeName}]') IS NOT NULL THEN 1 ELSE 0 END\";");
        sb.AppendLine("        var result = await cmd.ExecuteScalarAsync(ct).ConfigureAwait(false);");
        sb.AppendLine("        return Convert.ToInt32(result) == 1;");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateValidateAsyncMethod(StringBuilder sb, string schemaName, string typeName)
    {
        GenerateValidateAsyncSignature(sb);
        GenerateValidateAsyncBody(sb, schemaName, typeName);
    }

    private static void GenerateValidateAsyncSignature(StringBuilder sb)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Validates that the TVP exists and matches expected schema.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    /// <returns>Tuple of (exists, isValid, errorMessage).</returns>");
        sb.AppendLine("    public static async Task<(bool Exists, bool IsValid, string? Error)> ValidateAsync(");
        sb.AppendLine("        SqlConnection connection,");
        sb.AppendLine("        CancellationToken ct = default)");
        sb.AppendLine("    {");
    }

    private static void GenerateValidateAsyncBody(StringBuilder sb, string schemaName, string typeName)
    {
        GenerateValidateExistsCheck(sb, schemaName, typeName);
        GenerateValidateQuery(sb, schemaName, typeName);
        GenerateValidateComparison(sb);
    }

    private static void GenerateValidateExistsCheck(StringBuilder sb, string schemaName, string typeName)
    {
        sb.AppendLine("        var exists = await ExistsAsync(connection, ct).ConfigureAwait(false);");
        sb.AppendLine("        if (!exists)");
        sb.AppendLine("        {");
        sb.AppendLine($"            return (false, false, \"TVP type '[{schemaName}].[{typeName}]' does not exist.\");");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateValidateQuery(StringBuilder sb, string schemaName, string typeName)
    {
        sb.AppendLine("        await using var cmd = connection.CreateCommand();");
        sb.AppendLine("        cmd.CommandText = \"\"\"");
        sb.AppendLine("            SELECT c.name, t.name AS typeName, c.max_length, c.[precision], c.scale, c.is_nullable");
        sb.AppendLine("            FROM sys.table_types tt");
        sb.AppendLine("            INNER JOIN sys.schemas s ON tt.schema_id = s.schema_id");
        sb.AppendLine("            INNER JOIN sys.columns c ON c.object_id = tt.type_table_object_id");
        sb.AppendLine("            INNER JOIN sys.types t ON c.user_type_id = t.user_type_id");
        sb.AppendLine($"            WHERE s.name = '{schemaName}' AND tt.name = '{typeName}'");
        sb.AppendLine("            ORDER BY c.column_id");
        sb.AppendLine("            \"\"\";");
        sb.AppendLine();
        sb.AppendLine("        var dbColumns = new List<(string Name, string Type, bool IsNullable)>();");
        sb.AppendLine("        await using var reader = await cmd.ExecuteReaderAsync(ct).ConfigureAwait(false);");
        sb.AppendLine("        while (await reader.ReadAsync(ct).ConfigureAwait(false))");
        sb.AppendLine("        {");
        sb.AppendLine("            dbColumns.Add((reader.GetString(0), reader.GetString(1), reader.GetBoolean(5)));");
        sb.AppendLine("        }");
        sb.AppendLine();
    }

    private static void GenerateValidateComparison(StringBuilder sb)
    {
        sb.AppendLine("        if (dbColumns.Count != ExpectedColumns.Length)");
        sb.AppendLine("        {");
        sb.AppendLine("            return (true, false, $\"Column count mismatch. Expected {ExpectedColumns.Length}, found {dbColumns.Count}.\");");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        for (var i = 0; i < ExpectedColumns.Length; i++)");
        sb.AppendLine("        {");
        sb.AppendLine("            var expected = ExpectedColumns[i];");
        sb.AppendLine("            var actual = dbColumns[i];");
        sb.AppendLine("            if (!string.Equals(expected.Name, actual.Name, StringComparison.OrdinalIgnoreCase))");
        sb.AppendLine("            {");
        sb.AppendLine("                return (true, false, $\"Column {i} name mismatch. Expected '{expected.Name}', found '{actual.Name}'.\");");
        sb.AppendLine("            }");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return (true, true, null);");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateValidateSyncMethod(StringBuilder sb, string schemaName, string typeName)
    {
        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Validates that the TVP exists and matches expected schema (synchronous).");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine("    public static (bool Exists, bool IsValid, string? Error) Validate(SqlConnection connection)");
        sb.AppendLine("    {");
        sb.AppendLine("        using var cmd = connection.CreateCommand();");
        sb.AppendLine($"        cmd.CommandText = \"SELECT CASE WHEN TYPE_ID('[{schemaName}].[{typeName}]') IS NOT NULL THEN 1 ELSE 0 END\";");
        sb.AppendLine("        var exists = Convert.ToInt32(cmd.ExecuteScalar()) == 1;");
        sb.AppendLine("        if (!exists)");
        sb.AppendLine("        {");
        sb.AppendLine($"            return (false, false, \"TVP type '[{schemaName}].[{typeName}]' does not exist.\");");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return (true, true, null); // Simplified sync validation");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateGetHashMethod(StringBuilder sb, IList<PropertyColumnInfo> columns)
    {
        var hash = ComputeDefinitionHash(columns);

        sb.AppendLine("    /// <summary>");
        sb.AppendLine("    /// Gets the expected schema hash for this TVP definition.");
        sb.AppendLine("    /// </summary>");
        sb.AppendLine($"    public static string ExpectedHash => \"{hash}\";");
    }

    private static string ComputeDefinitionHash(IList<PropertyColumnInfo> columns)
    {
        var sb = new StringBuilder();
        for (var i = 0; i < columns.Count; i++)
        {
            if (i > 0)
            {
                sb.Append(',');
            }

            var col = columns[i];
            var columnName = col.ColumnName ?? col.PropertyName;
            var sqlType = GetBaseSqlType(col);

            sb.Append(columnName);
            sb.Append('|');
            sb.Append(sqlType);
            sb.Append('|');
            sb.Append(GetMaxLength(col));
            sb.Append('|');
            sb.Append(col.Precision);
            sb.Append('|');
            sb.Append(col.Scale);
            sb.Append('|');
            sb.Append(col.IsNullable ? '1' : '0');
        }

        var bytes = Encoding.UTF8.GetBytes(sb.ToString());
        using var sha256 = SHA256.Create();
        var hash = sha256.ComputeHash(bytes);
        var hexBuilder = new StringBuilder(32);
        for (var i = 0; i < 8; i++)
        {
            hexBuilder.Append(hash[i].ToString("X2"));
        }

        return hexBuilder.ToString();
    }

    private static string GetSqlColumnDefinition(PropertyColumnInfo col)
    {
        var baseType = col.PropertyType.TrimEnd('?');

        return baseType switch
        {
            "int" or "System.Int32" => "INT",
            "long" or "System.Int64" => "BIGINT",
            "short" or "System.Int16" => "SMALLINT",
            "byte" or "System.Byte" => "TINYINT",
            "sbyte" or "System.SByte" => "SMALLINT",
            "ushort" or "System.UInt16" => "INT",
            "uint" or "System.UInt32" => "BIGINT",
            "ulong" or "System.UInt64" => "DECIMAL(20,0)",
            "bool" or "System.Boolean" => "BIT",
            "string" or "System.String" => GetStringType(col),
            "decimal" or "System.Decimal" => $"DECIMAL({col.Precision},{col.Scale})",
            "double" or "System.Double" => "FLOAT",
            "float" or "System.Single" => "REAL",
            "System.DateTime" => GetDateTimeType(col),
            "System.DateTimeOffset" => $"DATETIMEOFFSET({col.DateTimePrecision})",
            "System.Guid" => "UNIQUEIDENTIFIER",
            "byte[]" or "System.Byte[]" => GetBinaryType(col),
            "System.TimeSpan" => $"TIME({col.DateTimePrecision})",
            "System.DateOnly" or "DateOnly" => "DATE",
            "System.TimeOnly" or "TimeOnly" => $"TIME({col.DateTimePrecision})",
            _ => "NVARCHAR(MAX)",
        };
    }

    private static string GetBaseSqlType(PropertyColumnInfo col)
    {
        var baseType = col.PropertyType.TrimEnd('?');

        return baseType switch
        {
            "int" or "System.Int32" => "int",
            "long" or "System.Int64" => "bigint",
            "short" or "System.Int16" => "smallint",
            "byte" or "System.Byte" => "tinyint",
            "bool" or "System.Boolean" => "bit",
            "string" or "System.String" => "nvarchar",
            "decimal" or "System.Decimal" => "decimal",
            "double" or "System.Double" => "float",
            "float" or "System.Single" => "real",
            "System.DateTime" => "datetime2",
            "System.DateTimeOffset" => "datetimeoffset",
            "System.Guid" => "uniqueidentifier",
            "byte[]" or "System.Byte[]" => "varbinary",
            "System.TimeSpan" => "time",
            "System.DateOnly" or "DateOnly" => "date",
            "System.TimeOnly" or "TimeOnly" => "time",
            _ => "nvarchar",
        };
    }

    private static int GetMaxLength(PropertyColumnInfo col)
    {
        var baseType = col.PropertyType.TrimEnd('?');

        if (baseType is "string" or "System.String")
        {
            var length = col.Length == -2 ? 4000 : col.Length;
            return length == -1 ? -1 : length * 2; // nvarchar uses 2 bytes per char
        }

        if (baseType is "byte[]" or "System.Byte[]")
        {
            return col.Length == -2 ? -1 : col.Length;
        }

        return 0;
    }

    private static string GetStringType(PropertyColumnInfo col)
    {
        var length = col.Length == -2 ? 4000 : col.Length;
        return length == -1 ? "NVARCHAR(MAX)" : $"NVARCHAR({length})";
    }

    private static string GetDateTimeType(PropertyColumnInfo col)
    {
        if (!string.IsNullOrEmpty(col.SqlType))
        {
            return col.SqlType!.ToUpperInvariant() switch
            {
                "DATE" => "DATE",
                "DATETIME" => "DATETIME",
                "SMALLDATETIME" => "SMALLDATETIME",
                _ => $"DATETIME2({col.DateTimePrecision})",
            };
        }

        return $"DATETIME2({col.DateTimePrecision})";
    }

    private static string GetBinaryType(PropertyColumnInfo col)
    {
        var length = col.Length == -2 ? -1 : col.Length;
        return length == -1 ? "VARBINARY(MAX)" : $"VARBINARY({length})";
    }
}
