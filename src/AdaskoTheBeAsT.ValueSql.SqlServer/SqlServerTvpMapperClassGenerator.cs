using System;
using System.Collections.Generic;
using System.Text;
using AdaskoTheBeAsT.ValueSql.SourceGenerator;

namespace AdaskoTheBeAsT.ValueSql.SqlServer;

/// <summary>
/// Generates TVP mapper code for SQL Server Table-Valued Parameters.
/// Supports SqlDataRecord (fastest) and DbDataReader (IDataReader compatible) modes.
/// </summary>
public static class SqlServerTvpMapperClassGenerator
{
    public static string Generate(
        string namespaceName,
        string className,
        string typeName,
        string? schema,
        int generationMode,
        IList<PropertyColumnInfo> properties)
    {
        var sb = new StringBuilder(4096);

        GenerateHeader(sb);
        GenerateUsings(sb, generationMode);
        GenerateNamespaceOpen(sb, namespaceName);
        GenerateMapperStruct(sb, className, typeName, schema, generationMode, properties);

        // Generate DataReader class if DbDataReader mode is enabled
        if (generationMode == 1 || generationMode == 2)
        {
            sb.AppendLine();
            GenerateDataReaderClass(sb, className, properties);
        }

        return sb.ToString();
    }

    private static void GenerateHeader(StringBuilder sb)
    {
        sb.AppendLine("// <auto-generated />");
        sb.AppendLine("#nullable enable");
        sb.AppendLine("#pragma warning disable CS8618 // Non-nullable field uninitialized");
        sb.AppendLine("#pragma warning disable CS8603 // Possible null reference return");
        sb.AppendLine();
    }

    private static void GenerateUsings(StringBuilder sb, int generationMode)
    {
        sb.AppendLine("using System;");
        sb.AppendLine("using System.Collections.Frozen;");
        sb.AppendLine("using System.Collections.Generic;");
        sb.AppendLine("using System.Data;");
        sb.AppendLine("using System.Runtime.CompilerServices;");

        // SqlDataRecord mode (0) or Both (2)
        if (generationMode == 0 || generationMode == 2)
        {
            sb.AppendLine("using Microsoft.Data.SqlClient.Server;");
        }

        sb.AppendLine("using AdaskoTheBeAsT.ValueSql.Runtime;");
        sb.AppendLine();
    }

    private static void GenerateNamespaceOpen(StringBuilder sb, string namespaceName)
    {
        sb.AppendLine($"namespace {namespaceName};");
        sb.AppendLine();
    }

    private static void GenerateMapperStruct(
        StringBuilder sb,
        string className,
        string typeName,
        string? schema,
        int generationMode,
        IList<PropertyColumnInfo> properties)
    {
        var mapperName = $"{className}TvpMapper";
        var fullTypeName = string.IsNullOrEmpty(schema) ? typeName : $"{schema}.{typeName}";

        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// High-performance TVP mapper for {className}.");
        sb.AppendLine($"/// SQL Type: {fullTypeName}");
        sb.AppendLine("/// </summary>");

        // Determine which interfaces to implement
        var interfaces = new List<string>();
        if (generationMode == 0 || generationMode == 2)
        {
            interfaces.Add($"IValueSqlTvpMapperFast<{className}>");
        }

        if (generationMode == 1 || generationMode == 2)
        {
            interfaces.Add($"AdaskoTheBeAsT.ValueSql.Abstractions.IValueSqlTvpMapper<{className}>");
        }

        var interfaceList = interfaces.Count > 0 ? $" : {string.Join(", ", interfaces)}" : string.Empty;

        sb.AppendLine($"public readonly struct {mapperName}{interfaceList}");
        sb.AppendLine("{");

        // Static metadata cache for SqlDataRecord
        if (generationMode == 0 || generationMode == 2)
        {
            GenerateMetaDataCache(sb, properties);
            sb.AppendLine();
        }

        GenerateSqlTypeName(sb, fullTypeName);
        sb.AppendLine();

        if (generationMode == 0 || generationMode == 2)
        {
            GenerateGetMetaData(sb);
            sb.AppendLine();
            GenerateToSqlDataRecords(sb, className, properties);
        }

        // DbDataReader implementation
        if (generationMode == 1 || generationMode == 2)
        {
            if (generationMode == 2)
            {
                sb.AppendLine();
            }

            GenerateToDataReader(sb, className);
        }

        sb.AppendLine("}");
    }

    private static void GenerateMetaDataCache(StringBuilder sb, IList<PropertyColumnInfo> properties)
    {
        sb.AppendLine("    // Cached SqlMetaData for zero-allocation reuse");
        sb.AppendLine("    private static readonly SqlMetaData[] CachedMetaData =");
        sb.AppendLine("    [");

        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var sqlDbType = GetSqlDbType(prop);
            var metaData = GetSqlMetaDataConstructor(prop, sqlDbType);
            var comma = i < properties.Count - 1 ? "," : string.Empty;
            sb.AppendLine($"        {metaData}{comma}");
        }

        sb.AppendLine("    ];");
    }

    private static void GenerateSqlTypeName(StringBuilder sb, string fullTypeName)
    {
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine($"    public string SqlTypeName => \"{fullTypeName}\";");
    }

    private static void GenerateGetMetaData(StringBuilder sb)
    {
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public SqlMetaData[] GetMetaData() => CachedMetaData;");
    }

    private static void GenerateToSqlDataRecords(
        StringBuilder sb,
        string className,
        IList<PropertyColumnInfo> properties)
    {
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine($"    public IEnumerable<SqlDataRecord> ToSqlDataRecords(IEnumerable<{className}> items)");
        sb.AppendLine("    {");
        sb.AppendLine("        var record = new SqlDataRecord(CachedMetaData);");
        sb.AppendLine();
        sb.AppendLine("        foreach (var item in items)");
        sb.AppendLine("        {");

        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var setStatement = GenerateSetValueStatement(i, prop);
            sb.AppendLine($"            {setStatement}");
        }

        sb.AppendLine();
        sb.AppendLine("            yield return record;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateToDataReader(StringBuilder sb, string className)
    {
        sb.AppendLine("    /// <inheritdoc />");
        sb.AppendLine($"    public IDataReader ToDataReader(IEnumerable<{className}> items)");
        sb.AppendLine("    {");
        sb.AppendLine($"        return new {className}TvpDataReader(items);");
        sb.AppendLine("    }");
    }

    private static void GenerateDataReaderClass(
        StringBuilder sb,
        string className,
        IList<PropertyColumnInfo> properties)
    {
        var readerName = $"{className}TvpDataReader";

        GenerateDataReaderHeader(sb, className, readerName);
        GenerateDataReaderArrays(sb, properties);
        GenerateDataReaderProperties(sb, properties.Count);
        GenerateDataReaderGetValue(sb, properties);
        GenerateDataReaderHelperMethods(sb);
        GenerateIsDBNull(sb, properties);
        GenerateTypeSpecificGetters(sb, properties);
        GenerateDataReaderGetValues(sb, properties.Count);
        GenerateDataReaderDispose(sb);

        sb.AppendLine("}");
    }

    private static void GenerateDataReaderHeader(StringBuilder sb, string className, string readerName)
    {
        sb.AppendLine("/// <summary>");
        sb.AppendLine($"/// Streaming IDataReader implementation for {className} TVP.");
        sb.AppendLine("/// </summary>");
        sb.AppendLine("[SkipLocalsInit]");
        sb.AppendLine($"internal sealed class {readerName} : IDataReader");
        sb.AppendLine("{");
        sb.AppendLine($"    private readonly IEnumerator<{className}> _enumerator;");
        sb.AppendLine("    private bool _disposed;");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine($"    public {readerName}(IEnumerable<{className}> items)");
        sb.AppendLine("    {");
        sb.AppendLine("        _enumerator = items.GetEnumerator();");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateDataReaderArrays(StringBuilder sb, IList<PropertyColumnInfo> properties)
    {
        sb.AppendLine("    private static readonly string[] ColumnNames =");
        sb.AppendLine("    [");
        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var columnName = prop.ColumnName ?? prop.PropertyName;
            var comma = i < properties.Count - 1 ? "," : string.Empty;
            sb.AppendLine($"        \"{columnName}\"{comma}");
        }

        sb.AppendLine("    ];");
        sb.AppendLine();

        // FrozenDictionary for O(1) ordinal lookup
        sb.AppendLine("    private static readonly FrozenDictionary<string, int> OrdinalLookup = new Dictionary<string, int>(StringComparer.OrdinalIgnoreCase)");
        sb.AppendLine("    {");
        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var columnName = prop.ColumnName ?? prop.PropertyName;
            var comma = i < properties.Count - 1 ? "," : string.Empty;
            sb.AppendLine($"        {{ \"{columnName}\", {i} }}{comma}");
        }

        sb.AppendLine("    }.ToFrozenDictionary(StringComparer.OrdinalIgnoreCase);");
        sb.AppendLine();

        sb.AppendLine("    private static readonly Type[] ColumnTypes =");
        sb.AppendLine("    [");
        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var clrType = GetClrTypeForTypeof(prop.PropertyType);
            var comma = i < properties.Count - 1 ? "," : string.Empty;
            sb.AppendLine($"        typeof({clrType}){comma}");
        }

        sb.AppendLine("    ];");
        sb.AppendLine();
    }

    private static void GenerateDataReaderProperties(StringBuilder sb, int fieldCount)
    {
        sb.AppendLine($"    public int FieldCount => {fieldCount};");
        sb.AppendLine("    public int Depth => 0;");
        sb.AppendLine("    public bool IsClosed => _disposed;");
        sb.AppendLine("    public int RecordsAffected => -1;");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public object this[int i] => GetValue(i);");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public object this[string name] => GetValue(GetOrdinal(name));");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public bool Read() => _enumerator.MoveNext();");
        sb.AppendLine();
    }

    private static void GenerateDataReaderGetValue(StringBuilder sb, IList<PropertyColumnInfo> properties)
    {
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public object GetValue(int i)");
        sb.AppendLine("    {");
        sb.AppendLine("        var item = _enumerator.Current;");
        sb.AppendLine("        return i switch");
        sb.AppendLine("        {");
        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var valueExpr = GetValueExpression(prop);
            sb.AppendLine($"            {i} => {valueExpr},");
        }

        sb.AppendLine("            _ => throw new IndexOutOfRangeException(),");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static string GetValueExpression(PropertyColumnInfo prop)
    {
        var baseType = prop.PropertyType.TrimEnd('?');

        // Handle DateOnly/TimeOnly conversion to avoid boxing issues
        if (baseType is "System.DateOnly" or "DateOnly")
        {
            return prop.IsNullable
                ? $"item.{prop.PropertyName}.HasValue ? item.{prop.PropertyName}.Value.ToDateTime(TimeOnly.MinValue) : DBNull.Value"
                : $"item.{prop.PropertyName}.ToDateTime(TimeOnly.MinValue)";
        }

        if (baseType is "System.TimeOnly" or "TimeOnly")
        {
            return prop.IsNullable
                ? $"item.{prop.PropertyName}.HasValue ? item.{prop.PropertyName}.Value.ToTimeSpan() : DBNull.Value"
                : $"item.{prop.PropertyName}.ToTimeSpan()";
        }

        return prop.IsNullable
            ? $"(object?)item.{prop.PropertyName} ?? DBNull.Value"
            : $"item.{prop.PropertyName}";
    }

    private static void GenerateDataReaderHelperMethods(StringBuilder sb)
    {
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public string GetName(int i) => ColumnNames[i];");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public int GetOrdinal(string name) => OrdinalLookup.TryGetValue(name, out var ordinal) ? ordinal : -1;");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public Type GetFieldType(int i) => ColumnTypes[i];");
        sb.AppendLine();
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public string GetDataTypeName(int i) => ColumnTypes[i].Name;");
        sb.AppendLine();
    }

    private static void GenerateIsDBNull(StringBuilder sb, IList<PropertyColumnInfo> properties)
    {
        sb.AppendLine("    [MethodImpl(MethodImplOptions.AggressiveInlining)]");
        sb.AppendLine("    public bool IsDBNull(int i)");
        sb.AppendLine("    {");
        sb.AppendLine("        var item = _enumerator.Current;");
        sb.AppendLine("        return i switch");
        sb.AppendLine("        {");
        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var nullCheck = prop.IsNullable
                ? $"item.{prop.PropertyName} == null"
                : "false";
            sb.AppendLine($"            {i} => {nullCheck},");
        }

        sb.AppendLine("            _ => throw new IndexOutOfRangeException(),");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
        sb.AppendLine();
    }

    private static void GenerateDataReaderGetValues(StringBuilder sb, int fieldCount)
    {
        sb.AppendLine("    public int GetValues(object[] values)");
        sb.AppendLine("    {");
        sb.AppendLine($"        var count = Math.Min(values.Length, {fieldCount});");
        sb.AppendLine("        for (var i = 0; i < count; i++)");
        sb.AppendLine("        {");
        sb.AppendLine("            values[i] = GetValue(i);");
        sb.AppendLine("        }");
        sb.AppendLine();
        sb.AppendLine("        return count;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public bool NextResult() => false;");
        sb.AppendLine("    public DataTable? GetSchemaTable() => null;");
        sb.AppendLine();
    }

    private static void GenerateDataReaderDispose(StringBuilder sb)
    {
        sb.AppendLine("    public void Close() => Dispose();");
        sb.AppendLine();
        sb.AppendLine("    public void Dispose()");
        sb.AppendLine("    {");
        sb.AppendLine("        if (!_disposed)");
        sb.AppendLine("        {");
        sb.AppendLine("            _enumerator.Dispose();");
        sb.AppendLine("            _disposed = true;");
        sb.AppendLine("        }");
        sb.AppendLine("    }");
    }

    private static void GenerateTypeSpecificGetters(StringBuilder sb, IList<PropertyColumnInfo> properties)
    {
        // Generate optimized type-specific getters with direct property access (no boxing)
        GenerateTypedGetter(sb, "bool", "GetBoolean", properties);
        GenerateTypedGetter(sb, "byte", "GetByte", properties);
        GenerateTypedGetter(sb, "char", "GetChar", properties);
        GenerateTypedGetter(sb, "DateTime", "GetDateTime", properties);
        GenerateTypedGetter(sb, "decimal", "GetDecimal", properties);
        GenerateTypedGetter(sb, "double", "GetDouble", properties);
        GenerateTypedGetter(sb, "float", "GetFloat", properties);
        GenerateTypedGetter(sb, "Guid", "GetGuid", properties);
        GenerateTypedGetter(sb, "short", "GetInt16", properties);
        GenerateTypedGetter(sb, "int", "GetInt32", properties);
        GenerateTypedGetter(sb, "long", "GetInt64", properties);
        GenerateTypedGetter(sb, "string", "GetString", properties);
        sb.AppendLine();

        sb.AppendLine("    public long GetBytes(int i, long fieldOffset, byte[]? buffer, int bufferOffset, int length)");
        sb.AppendLine("    {");
        sb.AppendLine("        var data = (byte[])GetValue(i);");
        sb.AppendLine("        if (buffer == null) return data.Length;");
        sb.AppendLine("        var copyLength = Math.Min(length, data.Length - (int)fieldOffset);");
        sb.AppendLine("        Array.Copy(data, (int)fieldOffset, buffer, bufferOffset, copyLength);");
        sb.AppendLine("        return copyLength;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public long GetChars(int i, long fieldOffset, char[]? buffer, int bufferOffset, int length)");
        sb.AppendLine("    {");
        sb.AppendLine("        var data = GetString(i).ToCharArray();");
        sb.AppendLine("        if (buffer == null) return data.Length;");
        sb.AppendLine("        var copyLength = Math.Min(length, data.Length - (int)fieldOffset);");
        sb.AppendLine("        Array.Copy(data, (int)fieldOffset, buffer, bufferOffset, copyLength);");
        sb.AppendLine("        return copyLength;");
        sb.AppendLine("    }");
        sb.AppendLine();
        sb.AppendLine("    public IDataReader GetData(int i) => throw new NotSupportedException();");
        sb.AppendLine();
    }

    private static void GenerateTypedGetter(
        StringBuilder sb,
        string returnType,
        string methodName,
        IList<PropertyColumnInfo> properties)
    {
        // Find properties that match this type
        var matchingProps = new List<(int Index, PropertyColumnInfo Prop)>();
        for (var i = 0; i < properties.Count; i++)
        {
            var prop = properties[i];
            var propType = GetClrTypeForTypeof(prop.PropertyType);
            if (string.Equals(propType, returnType, StringComparison.Ordinal))
            {
                matchingProps.Add((i, prop));
            }
        }

        if (matchingProps.Count == 0)
        {
            // No matching properties - fallback to cast from GetValue
            sb.AppendLine($"    public {returnType} {methodName}(int i) => ({returnType})GetValue(i);");
            return;
        }

        if (matchingProps.Count == 1)
        {
            // Single property - direct access with validation
            var (idx, prop) = matchingProps[0];
            var accessor = prop.IsNullable ? $"_enumerator.Current.{prop.PropertyName} ?? default" : $"_enumerator.Current.{prop.PropertyName}";
            sb.AppendLine($"    public {returnType} {methodName}(int i) => i == {idx} ? {accessor} : ({returnType})GetValue(i);");
            return;
        }

        // Multiple properties - use switch for direct access (no boxing)
        sb.AppendLine($"    public {returnType} {methodName}(int i)");
        sb.AppendLine("    {");
        sb.AppendLine("        var item = _enumerator.Current;");
        sb.AppendLine("        return i switch");
        sb.AppendLine("        {");
        foreach (var (idx, prop) in matchingProps)
        {
            var accessor = prop.IsNullable ? $"item.{prop.PropertyName} ?? default" : $"item.{prop.PropertyName}";
            sb.AppendLine($"            {idx} => {accessor},");
        }

        sb.AppendLine($"            _ => ({returnType})GetValue(i),");
        sb.AppendLine("        };");
        sb.AppendLine("    }");
    }

    private static string GenerateSetValueStatement(int ordinal, PropertyColumnInfo prop)
    {
        var baseType = prop.PropertyType.TrimEnd('?');
        return prop.IsNullable
            ? GenerateNullableSetValue(ordinal, prop.PropertyName, baseType)
            : GenerateNonNullableSetValue(ordinal, prop.PropertyName, baseType);
    }

    private static string GenerateNullableSetValue(int ordinal, string propName, string baseType) =>
        baseType switch
        {
            "string" or "System.String" =>
                $"if (item.{propName} != null) record.SetString({ordinal}, item.{propName}); else record.SetDBNull({ordinal});",
            "int" or "System.Int32" =>
                $"if (item.{propName}.HasValue) record.SetInt32({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "long" or "System.Int64" =>
                $"if (item.{propName}.HasValue) record.SetInt64({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "short" or "System.Int16" =>
                $"if (item.{propName}.HasValue) record.SetInt16({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "byte" or "System.Byte" =>
                $"if (item.{propName}.HasValue) record.SetByte({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "sbyte" or "System.SByte" =>
                $"if (item.{propName}.HasValue) record.SetValue({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "ushort" or "System.UInt16" =>
                $"if (item.{propName}.HasValue) record.SetInt32({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "uint" or "System.UInt32" =>
                $"if (item.{propName}.HasValue) record.SetInt64({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "ulong" or "System.UInt64" =>
                $"if (item.{propName}.HasValue) record.SetDecimal({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "bool" or "System.Boolean" =>
                $"if (item.{propName}.HasValue) record.SetBoolean({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "decimal" or "System.Decimal" =>
                $"if (item.{propName}.HasValue) record.SetDecimal({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "double" or "System.Double" =>
                $"if (item.{propName}.HasValue) record.SetDouble({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "float" or "System.Single" =>
                $"if (item.{propName}.HasValue) record.SetFloat({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "System.DateTime" =>
                $"if (item.{propName}.HasValue) record.SetDateTime({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "System.DateTimeOffset" =>
                $"if (item.{propName}.HasValue) record.SetDateTimeOffset({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "System.Guid" =>
                $"if (item.{propName}.HasValue) record.SetGuid({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "System.TimeSpan" =>
                $"if (item.{propName}.HasValue) record.SetTimeSpan({ordinal}, item.{propName}.Value); else record.SetDBNull({ordinal});",
            "System.DateOnly" or "DateOnly" =>
                $"if (item.{propName}.HasValue) record.SetDateTime({ordinal}, item.{propName}.Value.ToDateTime(TimeOnly.MinValue)); else record.SetDBNull({ordinal});",
            "System.TimeOnly" or "TimeOnly" =>
                $"if (item.{propName}.HasValue) record.SetTimeSpan({ordinal}, item.{propName}.Value.ToTimeSpan()); else record.SetDBNull({ordinal});",
            "byte[]" or "System.Byte[]" =>
                $"if (item.{propName} != null) record.SetBytes({ordinal}, 0, item.{propName}, 0, item.{propName}.Length); else record.SetDBNull({ordinal});",
            _ => $"if (item.{propName} != null) record.SetValue({ordinal}, item.{propName}); else record.SetDBNull({ordinal});",
        };

    private static string GenerateNonNullableSetValue(int ordinal, string propName, string baseType) =>
        baseType switch
        {
            "string" or "System.String" => $"record.SetString({ordinal}, item.{propName});",
            "int" or "System.Int32" => $"record.SetInt32({ordinal}, item.{propName});",
            "long" or "System.Int64" => $"record.SetInt64({ordinal}, item.{propName});",
            "short" or "System.Int16" => $"record.SetInt16({ordinal}, item.{propName});",
            "byte" or "System.Byte" => $"record.SetByte({ordinal}, item.{propName});",
            "sbyte" or "System.SByte" => $"record.SetValue({ordinal}, item.{propName});",
            "ushort" or "System.UInt16" => $"record.SetInt32({ordinal}, item.{propName});",
            "uint" or "System.UInt32" => $"record.SetInt64({ordinal}, item.{propName});",
            "ulong" or "System.UInt64" => $"record.SetDecimal({ordinal}, item.{propName});",
            "bool" or "System.Boolean" => $"record.SetBoolean({ordinal}, item.{propName});",
            "decimal" or "System.Decimal" => $"record.SetDecimal({ordinal}, item.{propName});",
            "double" or "System.Double" => $"record.SetDouble({ordinal}, item.{propName});",
            "float" or "System.Single" => $"record.SetFloat({ordinal}, item.{propName});",
            "System.DateTime" => $"record.SetDateTime({ordinal}, item.{propName});",
            "System.DateTimeOffset" => $"record.SetDateTimeOffset({ordinal}, item.{propName});",
            "System.Guid" => $"record.SetGuid({ordinal}, item.{propName});",
            "System.TimeSpan" => $"record.SetTimeSpan({ordinal}, item.{propName});",
            "System.DateOnly" or "DateOnly" => $"record.SetDateTime({ordinal}, item.{propName}.ToDateTime(TimeOnly.MinValue));",
            "System.TimeOnly" or "TimeOnly" => $"record.SetTimeSpan({ordinal}, item.{propName}.ToTimeSpan());",
            "byte[]" or "System.Byte[]" => $"record.SetBytes({ordinal}, 0, item.{propName}, 0, item.{propName}.Length);",
            _ => $"record.SetValue({ordinal}, item.{propName});",
        };

    private static string GetSqlDbType(PropertyColumnInfo prop)
    {
        // Check for explicit SQL type override first
        if (!string.IsNullOrEmpty(prop.SqlType))
        {
            return prop.SqlType!.ToUpperInvariant() switch
            {
                "DATE" => "SqlDbType.Date",
                "DATETIME" => "SqlDbType.DateTime",
                "DATETIME2" => "SqlDbType.DateTime2",
                "SMALLDATETIME" => "SqlDbType.SmallDateTime",
                "DATETIMEOFFSET" => "SqlDbType.DateTimeOffset",
                "TIME" => "SqlDbType.Time",
                "VARCHAR" => "SqlDbType.VarChar",
                "NVARCHAR" => "SqlDbType.NVarChar",
                "CHAR" => "SqlDbType.Char",
                "NCHAR" => "SqlDbType.NChar",
                "TEXT" => "SqlDbType.Text",
                "NTEXT" => "SqlDbType.NText",
                "BINARY" => "SqlDbType.Binary",
                "VARBINARY" => "SqlDbType.VarBinary",
                "IMAGE" => "SqlDbType.Image",
                "MONEY" => "SqlDbType.Money",
                "SMALLMONEY" => "SqlDbType.SmallMoney",
                "XML" => "SqlDbType.Xml",
                _ => "SqlDbType.NVarChar",
            };
        }

        var baseType = prop.PropertyType.TrimEnd('?');
        return baseType switch
        {
            "int" or "System.Int32" => "SqlDbType.Int",
            "long" or "System.Int64" => "SqlDbType.BigInt",
            "short" or "System.Int16" => "SqlDbType.SmallInt",
            "byte" or "System.Byte" => "SqlDbType.TinyInt",
            "sbyte" or "System.SByte" => "SqlDbType.SmallInt",
            "ushort" or "System.UInt16" => "SqlDbType.Int",
            "uint" or "System.UInt32" => "SqlDbType.BigInt",
            "ulong" or "System.UInt64" => "SqlDbType.Decimal",
            "bool" or "System.Boolean" => "SqlDbType.Bit",
            "string" or "System.String" => "SqlDbType.NVarChar",
            "decimal" or "System.Decimal" => "SqlDbType.Decimal",
            "double" or "System.Double" => "SqlDbType.Float",
            "float" or "System.Single" => "SqlDbType.Real",
            "System.DateTime" => "SqlDbType.DateTime2",
            "System.DateTimeOffset" => "SqlDbType.DateTimeOffset",
            "System.Guid" => "SqlDbType.UniqueIdentifier",
            "byte[]" or "System.Byte[]" => "SqlDbType.VarBinary",
            "System.TimeSpan" => "SqlDbType.Time",
            "System.DateOnly" => "SqlDbType.Date",
            "DateOnly" => "SqlDbType.Date",
            "System.TimeOnly" => "SqlDbType.Time",
            "TimeOnly" => "SqlDbType.Time",
            _ => "SqlDbType.NVarChar",
        };
    }

    private static string GetSqlMetaDataConstructor(PropertyColumnInfo prop, string sqlDbType)
    {
        var columnName = prop.ColumnName ?? prop.PropertyName;

        // Types requiring length parameter
        if (sqlDbType is "SqlDbType.NVarChar" or "SqlDbType.VarChar" or "SqlDbType.NChar" or "SqlDbType.Char")
        {
            var length = prop.Length == -2 ? 4000 : prop.Length; // -2 = default, -1 = MAX
            return $"new SqlMetaData(\"{columnName}\", {sqlDbType}, {length})";
        }

        if (sqlDbType is "SqlDbType.VarBinary" or "SqlDbType.Binary")
        {
            var length = prop.Length == -2 ? -1 : prop.Length; // default to MAX for binary
            return $"new SqlMetaData(\"{columnName}\", {sqlDbType}, {length})";
        }

        // Decimal with precision and scale
        if (string.Equals(sqlDbType, "SqlDbType.Decimal", StringComparison.Ordinal))
        {
            return $"new SqlMetaData(\"{columnName}\", {sqlDbType}, {prop.Precision}, {prop.Scale})";
        }

        // DateTime2, DateTimeOffset, Time with precision
        if (sqlDbType is "SqlDbType.DateTime2" or "SqlDbType.DateTimeOffset" or "SqlDbType.Time")
        {
            // SqlMetaData for these uses scale parameter for fractional seconds precision
            return $"new SqlMetaData(\"{columnName}\", {sqlDbType}, 0, {prop.DateTimePrecision})";
        }

        return $"new SqlMetaData(\"{columnName}\", {sqlDbType})";
    }

    private static string GetClrTypeForTypeof(string propertyType)
    {
        var baseType = propertyType.TrimEnd('?');
        return baseType switch
        {
            "int" or "System.Int32" => "int",
            "long" or "System.Int64" => "long",
            "short" or "System.Int16" => "short",
            "byte" or "System.Byte" => "byte",
            "sbyte" or "System.SByte" => "sbyte",
            "ushort" or "System.UInt16" => "ushort",
            "uint" or "System.UInt32" => "uint",
            "ulong" or "System.UInt64" => "ulong",
            "bool" or "System.Boolean" => "bool",
            "string" or "System.String" => "string",
            "decimal" or "System.Decimal" => "decimal",
            "double" or "System.Double" => "double",
            "float" or "System.Single" => "float",
            "System.DateTime" => "DateTime",
            "System.DateTimeOffset" => "DateTimeOffset",
            "System.Guid" => "Guid",
            "System.TimeSpan" => "TimeSpan",
            "System.DateOnly" or "DateOnly" => "DateOnly",
            "System.TimeOnly" or "TimeOnly" => "TimeOnly",
            "byte[]" or "System.Byte[]" => "byte[]",
            _ => "object",
        };
    }
}
